---
title: OrientaÃ§Ã£o a Objetos - Tell Don't Ask
category: ood
layout: post
date: 2015-07-31
---

Num [post anterior][1] vimos quanta informaÃ§Ã£o do desenvolvedor os
mÃ©todos de acesso escondem, nÃ£o dos objetos em si mas de como os desenvolvedores
podem usar esses objetos no dia a dia.

Continuando a mesma sÃ©rie de exemplos, vamos ver como unir dado e comportamento
para melhorar a comunicaÃ§Ã£o com nossos usuÃ¡rios (desenvolvedores).

## Dados vs Comportamentos

Nos examplos anteriores, tÃ­nhamos um valor de desconto em dinheiro. Um desconto
sÃ³ Ã© Ãºtil se aplicado Ã  alguma coisa, certo? Como nossa empresa fictÃ­cia vende livros,
vamos ver como seria usar dar desconto em um livro:

~~~ php
namespace MyApp\Promotion;

$book = new Product('Object Thinking (Developer Reference)', 60.00);
$blackFriday = new Discount\Money(10.00);

$finalPrice = $book->getPrice() - $blackFriday->getValue();
$book->setPrice($finalPrice);
~~~

No exemplo acima temos duas classes representando dois dados diferentes: `desconto`
e `produto`. Veja que o comportamento de cÃ¡lculo do desconto nÃ£o esta encapsulado
em nada, vamos resolver isso:

~~~ php
namespace MyApp\Promotion;

class DiscountCalculator
{
    public function applyDiscountOnProduct(
        Discount\Money $discount,
        Product $book
    ) {
        if ($discount->getValue() >= $book->getPrice()) {
            $message = sprintf(
                'Discount (%01.2f) is greater than book price (%01.2f).',
                $discount->getValue(),
                $book->getPrice()
            );
            throw new \UnexpectedValueException($message);
        }

        return $book->getPrice() - $discount->getValue();
    }
}
~~~

Agora temos nosso comportamento agindo em dois dados diferentes. Apesar de ser
um exemplo com classes, nada impede os seus dados de serem um array ou qualquer
outra estrutura de dados (apesar de saber que vocÃª prefere objetos ğŸ˜‰).

Vamos ver como fica o uso deles com nossa classe tilanga:

~~~ php
namespace MyApp\Promotion;

$calculator = new DiscountCalculator;
$book = new Product('Object Thinking (Developer Reference)', 60.00);
$guguFriday = new Discount\Money(50.00);

$customerCart = $calculator->applyDiscountOnProduct($guguFriday, $book);
~~~

Repare como *a calculadora* depende sempre dos dois objetos mas principalmente
do desconto, que Ã© quando ela Ã© necessÃ¡ria. Separar dados de comportamento pode
ser Ãºtil em alguns casos mas existe um grande poder (de comunicaÃ§Ã£o) em unir ambos,
alÃ©m de ser um dos fundamentos da OrientaÃ§Ã£o a Objetos:

> CÃ³digo procedural pega uma informaÃ§Ã£o e toma uma decisÃ£o. CÃ³digo orientado a
> objetos pede que objetos faÃ§am coisas.
>
> Alec Sharp

Separando *dado* de *comportamento* vocÃª cobra do usuÃ¡rio o conhecimento dos
comportamentos associados ao dado. Toda vez que alguÃ©m quiser saber o preÃ§o que
algum cliente pagou (ou vai pagar) por algo, ela precisa saber dos descontos e
aplicÃ¡-los. VocÃª acha mesmo que elas vÃ£o sempre saber disso?!

Papai Noel nÃ£o existe, nem o coelhinho da pÃ¡scoa. #prontofalei

## Tell, don't ask

O [Tell, don't ask][tda] basicamente diz que juntando os dois (dado e
comportamento) em uma Ãºnica classe, o desenvolvedor precisa saber menos e o
cÃ³digo tende a ficar mais conciso (e coeso, como  consequÃªncia).

Como ficaria nosso exemplo de desconto em dinheiro usando ele?

~~~ php
namespace Myapp\Promotion\Discount;

class Money
{
    private $amount = 0.00;

    public function __construct($amountToDiscount)
    {
        $this->amount = $amountToDiscount;
    }

    public function calculateProductFinalPrice(Product $product)
    {
        $newPrice = $product->getPrice() - $this->amount;
        if ($newPrice <= 0.00) {
            $message = sprintf(
                'Discount (%01.2f) is greater than book price (%01.2f).',
                $this->amount(),
                $product->getPrice()
            );
            throw new \UnexpectedValueException($message);
        }

        return $newPrice;
    }
}
~~~

Pronto. Jogamos a *calculadora* fora, tiramos o mÃ©todo de acesso pra retornar o
valor do desconto e colocamos o mÃ©todo da calculadora dentro do desconto.

Antes o desenvolvedor precisava saber o que fazer com aquele valor, agora ele
precisa decidir se o que ele precisa Ã© o valor do produto com o desconto aplicado
ou nÃ£o. Ã‰ justamente desse fato que sai o nome [do princÃ­pio][tda]: antes de
permitir algum usuÃ¡rio de pedir alguma coisa (dado), diga/ofereÃ§a a ele as
aÃ§Ãµes (comportamentos) que ele pode usar naquele objeto (dado+comportamento).

~~~ php
$book = new Product('Object Thinking (Developer Reference)', 60.00);
$blackFriday = new Discount\Money(10.00);

$customerCartValue = $blackFriday->calculateProductFinalPrice($book);
~~~

Pensando sempre em quem vai usar seu cÃ³digo, inclusive vocÃª, o cÃ³digo acima Ã©
mais simples e menos propenso aos erros de interpretaÃ§Ã£o no futuro.

Como todo comportamento de desconto estÃ¡ disponÃ­vel e pronto pra usar, expor o
valor de desconto atravÃ©s de um mÃ©todo de acesso Ã© desnecessÃ¡rio. Esse menor
nÃ­vel de exposiÃ§Ã£o torna o encapsulamento dos algoritmos melhor e portanto, mais
fÃ¡ceis de evoluir.

Ã‰ comum nas discussÃµes de segregar (ou nÃ£o) *dado* de *comportamento*, o pessoal
a favor da uniÃ£o de ambos citar o argumento [dos modelos anÃªmicos][anemic-models]
em [DDD][] mas, acho que ninguÃ©m precisa ir tÃ£o longe pra defender os benefÃ­cios
desse princÃ­pio.

## Agora queremos descontos em porcentagem!

Agora precisamos aplicar um desconto em porcentagem. Refletindo sobre o
problema, nÃ£o temos muito a fazer alÃ©m de criar outra classe de desconto
e mudar ou pouco como o valor final do livro Ã© calculado.

Acho sempre vÃ¡lido vocÃª pensar nas soluÃ§Ãµes por vocÃª, se possÃ­vel envie
elas pra mim depois. Como agora nÃ£o tenho muita opÃ§Ã£o, segue minha soluÃ§Ã£o
pro problema:

~~~ php
namespace MyApp\Promotion\Discount;

class Percentage
{
    private $fraction = 0.00;

    public function __construct($percentageToDiscount)
    {
        $value = $percentageToDiscount / 100;
        $this->fraction = (float) $value;
    }

    public function calculateProductFinalPrice(Product $product)
    {
        $discountValue = $product->getPrice() * $this->fraction;
        $newPrice = $product->getPrice() - $discountValue;
        if ($newPrice <= 0.00) {
            $message = sprintf(
                'Discount (%01.2f%%) makes product cost nothing!',
                $this->fraction * 100
            );
            throw new \UnexpectedValueException($message);
        }

        return $newPrice;
    }
}
~~~

Usar o [princÃ­pio][tda] forÃ§a vocÃª a imaginar como um objeto vai ser usado
e nas informaÃ§Ãµes que o usuÃ¡rio terÃ¡ quando for consumir a funcionalidade
da sua classe. Pra resolver isso, eu costumo tentar fazer o [cÃ³digo imitar
uma conversa entre duas pessoas][ddd].

Quando vocÃª recebe um desconto, como a pessoa comunica esse desconto a vocÃª?

1. VocÃª tem 25% de desconto em qualquer produto.
2. VocÃª sÃ³ vai pagar 75% do produto.
3. VocÃª vai pagar o valor do produto menos o valor dele multiplicado por 0.25.

Imaginando que as trÃªs conversas fossem um cÃ³digo de verdade, eu penso
imediatamente nos cÃ³digos abaixo:

~~~ php
namespace MyApp\Promotion;

// 1. VocÃª tem 25% de desconto em qualquer produto.
$blackFriday = new Discount\Percentage(25);

// 2. VocÃª sÃ³ vai pagar 75% do produto.
$blackFriday = new Discount\Percentage(75);

// 3. VocÃª vai pagar o valor do produto menos o valor dele multiplicado por 0.25.
$blackFriday = new Discount\Percentage(0.25);
~~~

Qualquer um dos trÃªs cÃ³digos pode funcionar, mas qual Ã© a real expectativa do
desenvolvedor quando for consumir o cÃ³digo existente?
[Deixar implementaÃ§Ã£o prÃ³xima da forma como vocÃªs conversam sobre uma
funcionalidade dentro da empresa][ddd] evita diversos problemas. Como na nossa
empresa fictÃ­cia nos comunicamos usando o primeiro caso, implementamos ele.

Repare no nome do primeiro argumento: `$percentageToDiscount`. Ele tira toda a
ambiguidade do processo e elimina a necessidade do desenvolvedor precisar ler o
resto da classe. AtravÃ©s de um [cÃ³digo limpo][clean] estamos sempre evitando a ambiguidade
e a dÃºvida onde pudermos.

As diferenÃ§as entre os casos 1 e 2 sÃ£o a forma como vocÃªs conversam sobre a
funcionalidade. JÃ¡ no caso 3 a coisa se degringola um pouco: VocÃª expÃµe a conta
de porcentagem pro cliente, o que pode ser prejudicial no futuro, como no [caso
dos mÃ©todos de acesso][1].

## Defendendo a separaÃ§Ã£o de comportamento e dados

Existem alguns vÃ¡rios argumentos a favor de manter os dois separados mas de forma alguma
vou esgotar essa discussÃ£o, nem que eu fosse presunÃ§oso o suficiente pra achar
que tenho essa capacidade, entÃ£o minha intenÃ§Ã£o Ã© te dar opÃ§Ãµes (ou novos problemas)
pra ao menos facilitar sua escolha.

O primeiro argumento contra a separaÃ§Ã£o costuma ser o da violaÃ§Ã£o de [SRP][], o
que Ã© Ã³timo se a pessoa se embasar na questÃ£o de responsabilidade. Ã‰ Ã³timo porque
a questÃ£o de responsabilidade em nada viola a unidade de dado e comportamento.
"Um motivo pra mudar" Ã© o que define "responsabilidade" no [SRP][], se vocÃª
fizer um bom trabalho de design vocÃª consegue ter ambos. NinguÃ©m disse que ia
ser fÃ¡cil.

O segundo argumento Ã© chato e costuma tocar objetos que precisam ser mapeados ou
serializados. Nesse caso, vocÃª tem uma classe que possui informaÃ§Ãµes alÃ©m de um
mÃ©todo que retorna o mapamento daquele objeto pra outro. VocÃª pode isolar o
mapeamento em outra classe e sempre que a estrutura de dados mudar, mudar essa
classe-mapa tambÃ©m - resumindo, uma bosta. VocÃª pode usar [Reflection][] e fazer
esse mapeamento com [InflexÃ£o][inflection], Ã© um jeito melhor de resolver esse
determinado problema e tenho certeza que nÃ£o Ã© o Ãºnico. Aqui o argumento Ã© chato
porque provavelmente vocÃª vai cair nos *trade-off*s: analisar diferentes soluÃ§Ãµes
e adotar a "menos pior" pro seu caso especÃ­fico.

Em todos os casos, repare que a opiniÃ£o pouco importa. Usar o "[Tell, don't ask][tda]"
nÃ£o precisa violar nenhum outro princÃ­pio independente da situaÃ§Ã£o mas te convido
a antes de pensar nos princÃ­pios, pensar em quem utilizarÃ¡ o cÃ³digo e se todas
as implicaÃ§Ãµes de negÃ³cio estarÃ£o tÃ£o claras pra eles quanto estÃ£o pra vocÃª. EsqueÃ§a
disso e use todos os princÃ­pios, vocÃª terÃ¡ problemas. NÃ£o disse que os princÃ­pios
sÃ£o ruins, sÃ³ disse que eles por si sÃ³ nÃ£o resolverÃ£o todos os seus problemas.

PS: Se vocÃª pensou em usar alguns desses argumentos pra defender [Active Record][ar],
eu tenho um argumento contra vocÃª: [SRP][] ğŸ˜„. Eu sou um filho da puta, to ligado. ğŸ˜˜

## ConclusÃµes

Assim como [o uso inconsicente dos mÃ©todos de acesso pode ser ruim][1], separar
*dado* dos seus *comportamentos* tambÃ©m Ã©.

Dar aos usuÃ¡rios do seu cÃ³digo aÃ§Ãµes a serem feitas em cima de determinados dados,
junto com eles, vai melhorar a comunicaÃ§Ã£o do seu cÃ³digo com eles. Ã‰ essa melhora
de comunicaÃ§Ã£o que impede os problemas de acontecerem.

Eu nÃ£o falei quase nada sobre o [TDA][], entÃ£o vÃ¡ ler mais a respeito:

* O [Andy Hunt e o Dave Thomas][pp] publicaram um [artigo no IEEE][2] alÃ©m de
  [outro bem mais detalhado no blog deles][tda]. Eu aconselho bastante a vocÃª
  ler eles! Eu podia ter colocado esses links na introduÃ§Ã£o e nÃ£o ter escrito
  absolutamente mais nada, mas como eu [peguei feijÃ£o e strogonoff hoje][self],
  considerem esses links o strogonoff.
* No [Cunningham & Cunningham Wiki][c2] existe [uma discussÃ£o][5] dos dois links
  acima com algumas conclusÃµes. VocÃª jÃ¡ sacou que nenhum dos links que eu ponho
  deveriam ser ignorados por vossa senhoria, certo?!
* O [Martin Fowler][fowler] publicou [no bliki dele][4] um artigo bem preguiÃ§oso
  a respeito do princÃ­pio. Se vocÃª gosta dele e estÃ¡ com tempo, vÃ¡ lÃ¡ ler, se nÃ£o
  vÃ¡ procurar alguÃ©m errado pelas internets. Com esse link aqui Ã© sÃ©rio, vocÃª
  nÃ£o via perder nada se nÃ£o ler.
* A [ThoughtBot][] fez [alguns exemplos em Ruby][6] que sÃ£o bacanas. Sem bla bla
  bla, sÃ³ exemplos.

PS: Meu obrigado pro [JoÃ£o][joao], [Nelson][] e [Cobucci][] pelo review a mais um
post. Eles sÃ£o uns ğŸ‘¼ !

[1]: https://blog.augustopascutti.com/orientaÃ§Ã£o%20a%20objetos/2015/06/25/oo-setters-getters.html
[2]: https://media.pragprog.com/articles/jan_03_enbug.pdf
[tda]: https://web.archive.org/web/20121227021359/pragprog.com:80/articles/tell-dont-ask
[4]: https://martinfowler.com/bliki/TellDontAsk.html
[5]: https://c2.com/cgi/wiki?TellDontAsk
[6]: https://robots.thoughtbot.com/tell-dont-ask
[anemic-models]: https://en.wikipedia.org/wiki/Anemic_domain_model
[clean]: https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882
[ddd]: https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215
[srp]: https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view?pli=1 "Uncle Bob: Single Responsability Principle"
[ar]: https://en.wikipedia.org/wiki/Active_record_pattern
[pp]: https://pragprog.com/about
[c2]: https://c2.com/cgi/wiki?WelcomeVisitors
[fowler]: https://martinfowler.com
[joao]: https://github.com/netojoaobatista/
[nelson]: https://twitter.com/nelson_senna
[cobucci]: https://github.com/lcobucci
[thoughtbot]: https://thoughtbot.com/
[reflection]: https://php.net/ReflectionClass
[inflection]: https://en.wikipedia.org/wiki/Inflection
[self]: https://twitter.com/augustohp/status/626032867798351872
